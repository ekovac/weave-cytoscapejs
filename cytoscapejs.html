<!DOCTYPE html>
<html>
<head>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
    <meta charset=utf-8 />
    <title>CytoscapeJS Weave Tool</title>
    <link href="cytoscapejs.css" rel="stylesheet" type="text/css"/>
    <script src="http://cytoscape.github.io/cytoscape.js/api/cytoscape.js-2.2.4/cytoscape.js"></script>
    <!-- script src="cytoscape.js"></script -->
    <script src="arbor.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="cubehelix.js" charset="utf-8"></script>
    <script src="WeaveExternalHelper.js"></script>
</head>
<body>
    <div id="cy">
    </div>
<script>
    cytoscape_style = 
        cytoscape.stylesheet()
            .selector('node')
                .css({
                        'content': 'data(name)',
                        'text-valign': 'center',
                        'color': 'white',
                        'text-outline-width': 2,
                        'text-outline-color': '#888'
                        })
            .selector('edge')
                .css({
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'haystack'
                        })
            .selector(':selected')
                .css({
                        'background-color': 'black',
                        'line-color': 'black',
                        'target-arrow-color': 'black',
                        'source-arrow-color': 'black'
                        })
            .selector('.faded')
                .css({
                        'opacity': 0.25,
                        'text-opacity': 0
                        })
            .selector('.hidden')
                .css({
                        'opacity': 0,
                        'text-opacity': 0
                        });

    var column_to_prop_mappings = {
        nodeLabel: "name",
        edgeSource: "source",
        edgeTarget: "target"
    };
    var node_column_names = ['nodeLabel', 'nodeColor'];
    var edge_column_names = ['edgeSource', 'edgeTarget'];

    function data_updated()
    {
        var node_keytype = toolPath.push('nodeLabel').getValue("getMetadata('keyType')");

        var node_data = toolPath.retrieveColumns(node_column_names);
        var edge_data = toolPath.retrieveColumns(edge_column_names);

        for (var col = 1; col < edge_column_names.length+1; col++)
        {
            column = edge_data[col];
            for (var row = 0; row < column.length; row++)
            {
                new_entry = { keyType: node_keytype, localName: edge_data[col][row].toString() }; // Add the keytype, convert localname to string
                edge_data[col][row] = toolPath.qkeyToString(new_entry);
            }
        }

        var nodes = Array(node_data[0].length);
        for (var row = 0; row < node_data[0].length; row++)
        {
            new_node = {};
            new_node.id = node_data[0][row];
            for (var col = 0; col < node_column_names.length; col++)
            {
                property = column_to_prop_mappings[node_column_names[col]];
                var value = node_data[col+1][row];
                if (typeof value == String)
                    new_node[property] = value.trim();
                else
                    new_node[property] = value;
            }
            nodes[row] = {data: new_node};
        }

        var edges = Array(edge_data[0].length);
        for (var row = 0; row < edge_data[0].length; row++)
        {
            new_edge = {};
            new_edge.id = edge_data[0][row];
            for (var col = 0; col < edge_column_names.length; col++)
            {
                property = column_to_prop_mappings[edge_column_names[col]];
                new_edge[property] = edge_data[col+1][row];
            }
            edges[row] = {data: new_edge};
        }
        cy.layout({name: 'circle'});
        cy.load({nodes: nodes, edges: edges});
    };
    var edge_index;
    var node_index;
    function build_indices(e)
    {
        node_index = build_index('node');
        edge_index = build_index('edge');
    }
    function build_index(group)
    {
        var index = {};
        var group_selection = cy.filter(group);
        for (var i = 0; i < group_selection.length; i++)
        {
            var ele = group_selection[i];
            index[ele.data().id] = ele;
        }
        return index;
    };

    function is_in(ele, obj)
    {
        if (typeof ele != "string") throw "is_in takes a string, not an object.";
        return obj[ele.data().id] != undefined;
    };
    function arr_to_obj(arr)
    {
        obj = {};
        for (var i = 0; i < arr.length; i++)
        {
            obj[arr[i]] = true;
        }
        return obj;
    };
    var selection_changed_calls = 0;


    function probe_changed()
    {

    };

    function probe(evt)
    {

    };
    function unprobe(evt)
    {

    };
    var local_selection = {};
    var selection_timeout_id = null;

    function selection_changed()
    {
        local_selection = arr_to_obj(toolPath.selection_keyset.getKeys());

        cy.off({select: add_to_selection, unselect: remove_from_selection});

        console.log("Unselecting...");
        cy.elements().unselect();
        console.log("Deselecting...");
        cy.filter(function(i, ele) { return is_in(ele.id(), local_selection); }).select();

        cy.on({select: add_to_selection, unselect: remove_from_selection});

        console.log("Weave selection_keyset changed!");
        console.log(Object.keys(local_selection));
    };

    function send_selection()
    {
        toolPath.selection_keyset.setKeys(Object.keys(local_selection));

        console.log("Updating Weave selection_keyset:");
        console.log(Object.keys(local_selection));

        selection_timeout_id = null;
    }
    function add_to_selection(evt)
    {
        ele = evt.cyTarget;
        local_selection[ele.id()] = true;
        if (selection_timeout_id == null)
            selection_timeout_id = window.setTimeout(send_selection, 100);
    }
    function remove_from_selection(evt)
    {
        ele = evt.cyTarget;
        delete local_selection[ele.id()];
        if (selection_timeout_id == null)
            selection_timeout_id = window.setTimeout(send_selection, 100);
    }

    function positions_changed()
    {
        var positions = null;
        var positions_str = toolPath.push('positions').getState();    

        try 
        {
            positions = JSON.parse(positions_str)
        }
        catch (e)
        {
            console.log(e);
        }

        if (positions == null)
            return;

        cy.nodes().positions(function (i, ele) { return positions[ele.id()]; });
    }

    var position_timeout_id = null;

    function send_positions(evt)
    {
        var nodes = cy.nodes();
        var idx;
        var positions = {};
        for (idx = 0; idx < nodes.length; idx++)
        {
            var id = nodes[idx].id();
            var pos = nodes[idx].position();
            positions[id] = pos;
        }
        toolPath.push('positions').state(JSON.stringify(positions));

        position_timeout_id = null;
    }
    function update_positions(evt)
    {
        if (position_timeout_id == null)
            position_timeout_id = window.setTimeout(send_positions, 50);
    }

    function array_to_set(arr)
    {
        new_set = {};
        for (var i in arr)
        {
            new_set[arr[i]] = true;
        }
        return new_set;
    }
    function is_in(key, set)
    {
        if (Array.isArray(set))
            return is_in(key, array_to_set(set));
        else
            return set[key] ? true : false;
    }

    var valid_layouts = ['null', 'random', 'preset', 'grid', 'circle', 'concentric', 'breadthfirst', 'arbor'];
    function layout_updated()
    {
        var layout_name = toolPath.push('layoutName').getState();
        var layout_params = toolPath.push('layoutParams').getState();
        var reset = false;

        if (!layout_params)
        {
            console.log("Resetting layout params");
            toolPath.push('layoutParams').state({});
            layout_params = {};
        }
        if (!is_in(layout_name, valid_layouts))
        {
            console.log("Resetting layout name");
            toolPath.push('layoutName').state("circle");
            layout_name = "circle";
        }


        layout_params['name'] = layout_name;


        console.log("layout updated.");
        cy.layout(layout_params);
    };

    var toolPath;
    $(function() {
    $('#cy').cytoscape( { style: cytoscape_style, ready: function () { 
        window.cy = this
        toolPath = weaveExternalInit();
        toolPath.newProperty('nodeLabel', 'DynamicColumn', data_updated)
                .newProperty('nodeColor', 'DynamicColumn', data_updated) // TODO
                .newProperty('nodeSize', 'DynamicColumn', data_updated) // TODO
                .newProperty('edgeSource', 'DynamicColumn', data_updated)
                .newProperty('edgeTarget', 'DynamicColumn', data_updated)
                .newProperty('layoutName', 'LinkableString', layout_updated)
                .newProperty('layoutParams', 'LinkableVariable', layout_updated)
                .newProperty('positions', 'LinkableString', positions_changed); // TODO
        
        toolPath.selection_keyset.addCallback(selection_changed, true);
        toolPath.probe_keyset.addCallback(probe_changed, true);

        cy.on({select: add_to_selection, unselect: remove_from_selection});
        cy.on({position: update_positions}, 'node');
        cy.on({mouseover: probe, mouseout: unprobe}, 'node');
        cy.on({mouseover: probe, mouseout: unprobe}, 'edge');
                } })
    });
</script>
</body>
</html>
