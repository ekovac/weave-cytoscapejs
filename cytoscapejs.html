<!DOCTYPE html>
<html>
<head>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
    <meta charset=utf-8 />
    <title>CytoscapeJS Weave Tool</title>
    <link href="cytoscapejs.css" rel="stylesheet" type="text/css"/>
    <script src="http://cytoscape.github.io/cytoscape.js/api/cytoscape.js-2.2.4/cytoscape.js"></script>
    <!-- script src="cytoscape.js"></script -->
    <script src="arbor.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="cubehelix.js" charset="utf-8"></script>
    <script src="WeaveExternalHelper.js"></script>
</head>
<body>
    <div id="cy">
        
    </div>
    <div id="controls">
            <button title="Zoom to Fit" onclick="cy.fit()">Z</button>
            <button title="Run layout" onclick="run_layout()">&#8634;</button>
            <button title="Open Attribute Selector" onclick="open_attribute_selector()"><bold>&#9082;</bold></button>
    </div>

<script>
    cytoscape_style = 
        cytoscape.stylesheet()
            .selector('node')
                .css({
                        'content': 'data(name)',
                        'text-valign': 'center',
                        'color': 'white',
                        'text-outline-width': 2,
                        'text-outline-color': '#888'
                        })
            .selector('edge')
                .css({
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'haystack'
                        })
            .selector(':selected')
                .css({
                        'background-color': 'black',
                        'line-color': 'black',
                        'target-arrow-color': 'black',
                        'source-arrow-color': 'black'
                        })
            .selector('.faded')
                .css({
                        'opacity': 0.25,
                        'text-opacity': 0
                        })
            .selector('.hidden')
                .css({
                        'opacity': 0,
                        'text-opacity': 0
                        });

    /* Session variable names */
    var NODE_LABEL = "Node Label";
    var NODE_COLOR = "Node Color";
    var NODE_SIZE = "Node Size";
    var EDGE_SOURCE = "Edge Source";
    var EDGE_TARGET = "Edge Target";
    var LAYOUT_NAME = "Layout Name";
    var LAYOUT_PARAMS = "Layout Parameters";
    var POSITIONS = "Positions";

    var column_to_prop_mappings = {};
    column_to_prop_mappings[NODE_LABEL] = "name";
    column_to_prop_mappings[EDGE_SOURCE] = "source";
    column_to_prop_mappings[EDGE_TARGET] = "target";

    var node_column_names = [NODE_LABEL, NODE_COLOR];
    var edge_column_names = [EDGE_SOURCE, EDGE_TARGET];

    function data_updated()
    {
        var node_keytype = toolPath.push(NODE_LABEL).getValue("getMetadata('keyType')");

        var node_data = toolPath.retrieveColumns(node_column_names);
        var edge_data = toolPath.retrieveColumns(edge_column_names);

        function fixNodeReferences(column)
        {
            for (var row = 0; row < column.length; row++)
            {
                if (column[row] === undefined) continue;
                new_entry = { localName: column[row], keyType: node_keytype };
                column[row] = toolPath.qkeyToString(new_entry);
            }
        }

        fixNodeReferences(edge_data[1]); // EDGE_SOURCE
        fixNodeReferences(edge_data[2]); // EDGE_TARGET

        var nodes = Array(node_data[0].length);
        for (var row = 0; row < node_data[0].length; row++)
        {
            new_node = {};
            new_node.id = node_data[0][row];
            for (var col = 0; col < node_column_names.length; col++)
            {
                property = column_to_prop_mappings[node_column_names[col]];
                var value = node_data[col+1][row];
                if (typeof value == String)
                    new_node[property] = value.trim();
                else
                    new_node[property] = value;
            }
            nodes[row] = {data: new_node};
        }

        var edges = Array(edge_data[0].length);
        for (var row = 0; row < edge_data[0].length; row++)
        {
            new_edge = {};
            new_edge.id = edge_data[0][row];
            for (var col = 0; col < edge_column_names.length; col++)
            {
                property = column_to_prop_mappings[edge_column_names[col]];
                new_edge[property] = edge_data[col+1][row];
            }
            edges[row] = {data: new_edge};
        }

        cy.load({nodes: nodes, edges: edges});
        run_layout();
    };

    function is_in(ele, obj)
    {
        if (typeof ele != "string") throw "is_in takes a string, not an object.";
        return obj[ele.data().id] != undefined;
    };
    function arr_to_obj(arr)
    {
        obj = {};
        for (var i = 0; i < arr.length; i++)
        {
            obj[arr[i]] = true;
        }
        return obj;
    };
    var selection_changed_calls = 0;


    function probe_changed()
    {

    };

    function probe(evt)
    {

    };
    function unprobe(evt)
    {

    };
    var local_selection = {};
    var selection_timeout_id = null;

    function selection_changed()
    {
        local_selection = arr_to_obj(toolPath.selection_keyset.getKeys());

        cy.off({select: add_to_selection, unselect: remove_from_selection});

        cy.elements().unselect();

        cy.filter(function(i, ele) { return is_in(ele.id(), local_selection); }).select();

        cy.on({select: add_to_selection, unselect: remove_from_selection});
    };

    function send_selection()
    {
        toolPath.selection_keyset.setKeys(Object.keys(local_selection));

        selection_timeout_id = null;
    }
    function add_to_selection(evt)
    {
        ele = evt.cyTarget;
        local_selection[ele.id()] = true;
        if (selection_timeout_id == null)
            selection_timeout_id = window.setTimeout(send_selection, 50);
    }
    function remove_from_selection(evt)
    {
        ele = evt.cyTarget;
        delete local_selection[ele.id()];
        if (selection_timeout_id == null)
            selection_timeout_id = window.setTimeout(send_selection, 50);
    }

    function qkeyStringToString(qkey_string)
    {
        return toolPath.qkeyToString(JSON.parse(qkey_string));
    }
    function stringToQKeyString(str)
    {
        return JSON.stringify(toolPath.stringToQKey(str));
    }

    function positions_changed()
    {
        console.log("positions changed");
        var positions = toolPath.push(POSITIONS).getState();

        if (positions == null || positions == "")
        {
            cy.layout(layout_params);
        }

        cy.nodes().positions(function (i, ele) { return positions[stringToQKeyString(ele.id())]; });
    }

    var position_timeout_id = null;

    function send_positions(evt)
    {
        console.log("sending positions");
        var nodes = cy.nodes();
        var idx;
        var positions = {};
        for (idx = 0; idx < nodes.length; idx++)
        {
            var id = stringToQKeyString(nodes[idx].id());
            var pos = nodes[idx].position();
            if (pos.x === undefined && pos.y === undefined)
            {
                continue;
            }
            positions[id] = pos;
        }
        toolPath.push(POSITIONS).state(positions);

        position_timeout_id = null;
    }
    function update_positions(evt)
    {
        if (position_timeout_id == null)
            position_timeout_id = window.setTimeout(send_positions, 50);
    }

    function array_to_set(arr)
    {
        new_set = {};
        for (var i in arr)
        {
            new_set[arr[i]] = true;
        }
        return new_set;
    }
    function is_in(key, set)
    {
        if (Array.isArray(set))
            return is_in(key, array_to_set(set));
        else
            return set[key] ? true : false;
    }

    var valid_layouts = ['null', 'random', 'preset', 'grid', 'circle', 'concentric', 'breadthfirst', 'arbor', 'springy'];

    function run_layout()
    {
        var layout_name = toolPath.push(LAYOUT_NAME).getState();
        var layout_params = toolPath.push(LAYOUT_PARAMS).getState();

        if (!layout_params)
        {
            toolPath.push(LAYOUT_PARAMS).state({});
            layout_params = {};
        }
        if (layout_name == null || !is_in(layout_name, valid_layouts))
        {
            toolPath.push(LAYOUT_NAME).state("circle");
            layout_name = "circle";
        }
        layout_params['name'] = layout_name;

        cy.layout(layout_params);
    };

    function open_attribute_selector()
    {
        toolPath.push(NODE_LABEL).libs("weave.ui.AttributeSelectorPanel").exec("AttributeSelectorPanel.open(this)");
        return;
    }

    var toolPath;
    $(function() {
    $('#cy').cytoscape( { style: cytoscape_style, ready: function () { 
        window.cy = this
        toolPath = weaveExternalInit();

        toolPath.request(LAYOUT_NAME, 'LinkableString')
                .request(LAYOUT_PARAMS, 'LinkableVariable')
                .newProperty(NODE_LABEL, 'DynamicColumn', data_updated)
                .newProperty(NODE_COLOR, 'DynamicColumn', data_updated) // TODO
                .newProperty(NODE_SIZE, 'DynamicColumn', data_updated) // TODO
                .newProperty(EDGE_SOURCE, 'DynamicColumn', data_updated) 
                .newProperty(EDGE_TARGET, 'DynamicColumn', data_updated)
                .newProperty(POSITIONS, 'LinkableVariable', positions_changed);
        
        toolPath.selection_keyset.addCallback(selection_changed, true);
        toolPath.probe_keyset.addCallback(probe_changed, true);

        cy.on({select: add_to_selection, unselect: remove_from_selection});
        cy.on({position: update_positions}, 'node');
        cy.on({mouseover: probe, mouseout: unprobe}, 'node');
        cy.on({mouseover: probe, mouseout: unprobe}, 'edge');
        } })
    });
</script>
</body>
</html>
